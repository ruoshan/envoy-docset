<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>xDS REST and gRPC protocol &mdash; envoy tag-v1.21.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/envoy.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/tabs.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Well Known Client Features" href="../api/client_features.html" />
    <link rel="prev" title="Custom Tag" href="../api-v3/type/tracing/v3/custom_tag.proto.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html">
            <img src="../_static/envoy-logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                tag-v1.21.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about_docs.html">About the documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../start/start.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration/configuration.html">Configuration reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../operations/operations.html">Operations and administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../extending/extending.html">Extending Envoy for custom use cases</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api/api.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api/api_supported_versions.html">Supported API versions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-v3/api.html">v3 API reference</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">xDS REST and gRPC protocol</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#resource-types">Resource Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#filesystem-subscriptions">Filesystem subscriptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#streaming-grpc-subscriptions">Streaming gRPC subscriptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#api-flow">API flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variants-of-the-xds-transport-protocol">Variants of the xDS Transport Protocol</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-xds-transport-protocol">The xDS transport Protocol</a></li>
<li class="toctree-l4"><a class="reference internal" href="#resource-warming">Resource warming</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ttl">TTL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregated-discovery-service">Aggregated Discovery Service</a></li>
<li class="toctree-l4"><a class="reference internal" href="#incremental-xds">Incremental xDS</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rest-json-polling-subscriptions">REST-JSON polling subscriptions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../api/client_features.html">Well Known Client Features</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/overview.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../version_history/version_history.html">Version history</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">envoy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../api/api.html">API</a> &raquo;</li>
      <li>xDS REST and gRPC protocol</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api-docs/xds_protocol.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="xds-rest-and-grpc-protocol">
<span id="xds-protocol"></span><h1>xDS REST and gRPC protocol<a class="headerlink" href="#xds-rest-and-grpc-protocol" title="Permalink to this headline">¶</a></h1>
<p>Envoy discovers its various dynamic resources via the filesystem or by
querying one or more management servers. Collectively, these discovery
services and their corresponding APIs are referred to as <em>xDS</em>.
Resources are requested via <em>subscriptions</em>, by specifying a filesystem
path to watch, initiating gRPC streams, or polling a REST-JSON URL. The
latter two methods involve sending requests with a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a>
proto payload. Resources are delivered in a
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>
proto payload in all methods. We discuss each type of subscription
below.</p>
<div class="section" id="resource-types">
<h2>Resource Types<a class="headerlink" href="#resource-types" title="Permalink to this headline">¶</a></h2>
<p>Every configuration resource in the xDS API has a type associated with it. Resource types follow a
<a class="reference external" href="https://github.com/envoyproxy/envoy/blob/v1.21.1/api/API_VERSIONING.md">versioning scheme</a>. Resource types are versioned independent of the
transports described below.</p>
<p>The following v3 xDS resource types are supported:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">envoy.config.listener.v3.Listener</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/config/route/v3/route.proto.html#envoy-v3-api-msg-config-route-v3-routeconfiguration"><span class="std std-ref">envoy.config.route.v3.RouteConfiguration</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/config/route/v3/scoped_route.proto.html#envoy-v3-api-msg-config-route-v3-scopedrouteconfiguration"><span class="std std-ref">envoy.config.route.v3.ScopedRouteConfiguration</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/config/route/v3/route_components.proto.html#envoy-v3-api-msg-config-route-v3-virtualhost"><span class="std std-ref">envoy.config.route.v3.VirtualHost</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">envoy.config.cluster.v3.Cluster</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/config/endpoint/v3/endpoint.proto.html#envoy-v3-api-msg-config-endpoint-v3-clusterloadassignment"><span class="std std-ref">envoy.config.endpoint.v3.ClusterLoadAssignment</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/extensions/transport_sockets/tls/v3/secret.proto.html#envoy-v3-api-msg-extensions-transport-sockets-tls-v3-secret"><span class="std std-ref">envoy.extensions.transport_sockets.tls.v3.Secret</span></a></p></li>
<li><p><a class="reference internal" href="../api-v3/service/runtime/v3/rtds.proto.html#envoy-v3-api-msg-service-runtime-v3-runtime"><span class="std std-ref">envoy.service.runtime.v3.Runtime</span></a></p></li>
</ul>
<p>The concept of <a class="reference external" href="https://developers.google.com/protocol-buffers/docs/proto3#any">type URLs</a>
appears below, and takes the form <code class="docutils literal notranslate"><span class="pre">type.googleapis.com/&lt;resource</span> <span class="pre">type&gt;</span></code> – e.g.,
<code class="docutils literal notranslate"><span class="pre">type.googleapis.com/envoy.config.cluster.v3.Cluster</span></code> for a <code class="docutils literal notranslate"><span class="pre">Cluster</span></code> resource. In various requests from
Envoy and responses by the management server, the resource type URL is stated.</p>
</div>
<div class="section" id="filesystem-subscriptions">
<h2>Filesystem subscriptions<a class="headerlink" href="#filesystem-subscriptions" title="Permalink to this headline">¶</a></h2>
<p>The simplest approach to delivering dynamic configuration is to place it
at a well known path specified in the <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-configsource"><span class="std std-ref">ConfigSource</span></a>.
Envoy will use <code class="docutils literal notranslate"><span class="pre">inotify</span></code> (<code class="docutils literal notranslate"><span class="pre">kqueue</span></code> on macOS) to monitor the file for
changes and parse the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> proto in the file on update.
Binary protobufs, JSON, YAML and proto text are supported formats for
the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>.</p>
<p>There is no mechanism available for filesystem subscriptions to ACK/NACK
updates beyond stats counters and logs. The last valid configuration for
an xDS API will continue to apply if an configuration update rejection
occurs.</p>
</div>
<div class="section" id="streaming-grpc-subscriptions">
<span id="xds-protocol-streaming-grpc-subscriptions"></span><h2>Streaming gRPC subscriptions<a class="headerlink" href="#streaming-grpc-subscriptions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="api-flow">
<h3>API flow<a class="headerlink" href="#api-flow" title="Permalink to this headline">¶</a></h3>
<p>For typical HTTP routing scenarios, the core resource types for the client’s configuration are
<code class="docutils literal notranslate"><span class="pre">Listener</span></code>, <code class="docutils literal notranslate"><span class="pre">RouteConfiguration</span></code>, <code class="docutils literal notranslate"><span class="pre">Cluster</span></code>, and <code class="docutils literal notranslate"><span class="pre">ClusterLoadAssignment</span></code>. Each <code class="docutils literal notranslate"><span class="pre">Listener</span></code> resource
may point to a <code class="docutils literal notranslate"><span class="pre">RouteConfiguration</span></code> resource, which may point to one or more <code class="docutils literal notranslate"><span class="pre">Cluster</span></code> resources,
and each <code class="docutils literal notranslate"><span class="pre">Cluster</span></code> resource may point to a <code class="docutils literal notranslate"><span class="pre">ClusterLoadAssignment</span></code> resource.</p>
<p>Envoy fetches all <code class="docutils literal notranslate"><span class="pre">Listener</span></code> and <code class="docutils literal notranslate"><span class="pre">Cluster</span></code> resources at startup. It then fetches whatever
<code class="docutils literal notranslate"><span class="pre">RouteConfiguration</span></code> and <code class="docutils literal notranslate"><span class="pre">ClusterLoadAssignment</span></code> resources that are required by the <code class="docutils literal notranslate"><span class="pre">Listener</span></code> and
<code class="docutils literal notranslate"><span class="pre">Cluster</span></code> resources. In effect, every <code class="docutils literal notranslate"><span class="pre">Listener</span></code> or <code class="docutils literal notranslate"><span class="pre">Cluster</span></code> resource is a root to part of Envoy’s
configuration tree.</p>
<p>A non-proxy client such as gRPC might start by fetching only the specific <code class="docutils literal notranslate"><span class="pre">Listener</span></code> resources
that it is interested in. It then fetches the <code class="docutils literal notranslate"><span class="pre">RouteConfiguration</span></code> resources required by those
<code class="docutils literal notranslate"><span class="pre">Listener</span></code> resources, followed by whichever <code class="docutils literal notranslate"><span class="pre">Cluster</span></code> resources are required by those
<code class="docutils literal notranslate"><span class="pre">RouteConfiguration</span></code> resources, followed by the <code class="docutils literal notranslate"><span class="pre">ClusterLoadAssignment</span></code> resources required
by the <code class="docutils literal notranslate"><span class="pre">Cluster</span></code> resources. In effect, the original <code class="docutils literal notranslate"><span class="pre">Listener</span></code> resources are the roots to
the client’s configuration tree.</p>
</div>
<div class="section" id="variants-of-the-xds-transport-protocol">
<h3>Variants of the xDS Transport Protocol<a class="headerlink" href="#variants-of-the-xds-transport-protocol" title="Permalink to this headline">¶</a></h3>
<div class="section" id="four-variants">
<h4>Four Variants<a class="headerlink" href="#four-variants" title="Permalink to this headline">¶</a></h4>
<p>There are four variants of the xDS transport protocol used via streaming gRPC, which cover all
combinations of two dimensions.</p>
<p>The first dimension is State of the World (SotW) vs. incremental. The SotW approach was the
original mechanism used by xDS, in which the client must specify all resource names it is
interested in with each request, and for LDS and CDS resources, the server must return all
resources that the client has subscribed to in each request. This means that if the client is
already subscribing to 99 resources and wants to add an additional one, it must send a request
with all 100 resource names, rather than just the one new one. And for LDS and CDS resources, the
server must then respond by sending all 100 resources, even if the 99 that were already subscribed
to have not changed. This mechanism can be a scalability limitation, which is why the incremental
protocol variant was introduced. The incremental approach allows both the client and server to
indicate only deltas relative to their previous state – i.e., the client can say that it wants
to add or remove its subscription to a particular resource name without resending those that have
not changed, and the server can send updates only for those resources that have changed. The
incremental protocol also provides a mechanism for lazy loading of resources. For details on the
incremental protocol, see <a class="reference internal" href="#xds-protocol-delta"><span class="std std-ref">Incremental xDS</span></a> below.</p>
<p>The second dimension is using a separate gRPC stream for each resource type vs. aggregating all
resource types onto a single gRPC stream. The former approach was the original mechanism used by
xDS, and it offers an eventual consistency model. The latter approach was added for environments
in which explicit control of sequencing is required. For details, see <a class="reference internal" href="#xds-protocol-eventual-consistency-considerations"><span class="std std-ref">Eventual consistency
considerations</span></a> below.</p>
<p>So, the four variants of the xDS transport protocol are:</p>
<ol class="arabic simple">
<li><p>State of the World (Basic xDS): SotW, separate gRPC stream for each resource type</p></li>
<li><p>Incremental xDS: incremental, separate gRPC stream for each resource type</p></li>
<li><p>Aggregated Discovery Service (ADS): SotW, aggregate stream for all resource types</p></li>
<li><p>Incremental ADS: incremental, aggregate stream for all resource types</p></li>
</ol>
</div>
<div class="section" id="rpc-services-and-methods-for-each-variant">
<h4>RPC Services and Methods for Each Variant<a class="headerlink" href="#rpc-services-and-methods-for-each-variant" title="Permalink to this headline">¶</a></h4>
<p>For the non-aggregated protocol variants, there is a separate RPC service for each resource type.
Each of these RPC services can provide a method for each of the SotW and Incremental protocol
variants. Here are the RPC services and methods for each resource type:</p>
<ul class="simple">
<li><p>Listener: Listener Discovery Service (LDS)
-  SotW: ListenerDiscoveryService.StreamListeners
-  Incremental: ListenerDiscoveryService.DeltaListeners</p></li>
<li><p>RouteConfiguration: Route Discovery Service (RDS)
-  SotW: RouteDiscoveryService.StreamRoutes
-  Incremental: RouteDiscoveryService.DeltaRoutes</p></li>
<li><p>ScopedRouteConfiguration: Scoped Route Discovery Service (SRDS)
-  SotW: ScopedRouteDiscoveryService.StreamScopedRoutes
-  Incremental: ScopedRouteDiscoveryService.DeltaScopedRoutes</p></li>
<li><p>VirtualHost: Virtual Host Discovery Service (VHDS)
-  SotW: N/A
-  Incremental: VirtualHostDiscoveryService.DeltaVirtualHosts</p></li>
<li><p>Cluster: Cluster Discovery Service (CDS)
-  SotW: ClusterDiscoveryService.StreamClusters
-  Incremental: ClusterDiscoveryService.DeltaClusters</p></li>
<li><p>ClusterLoadAssignment: Endpoint Discovery Service (EDS)
-  SotW: EndpointDiscoveryService.StreamEndpoints
-  Incremental: EndpointDiscoveryService.DeltaEndpoints</p></li>
<li><p>Secret: Secret Discovery Service (SDS)
-  SotW: SecretDiscoveryService.StreamSecrets
-  Incremental: SecretDiscoveryService.DeltaSecrets</p></li>
<li><p>Runtime: Runtime Discovery Service (RTDS)
-  SotW: RuntimeDiscoveryService.StreamRuntime
-  Incremental: RuntimeDiscoveryService.DeltaRuntime</p></li>
</ul>
<p>In the aggregated protocol variants, all resource types are multiplexed on a single gRPC stream,
where each resource type is treated as a separate logical stream within the aggregated stream.
In effect, it simply combines all of the above separate APIs into a single stream by treating
requests and responses for each resource type as a separate sub-stream on the single aggregated
stream. The RPC service and methods for the aggregated protocol variants are:</p>
<ul class="simple">
<li><p>SotW: AggregatedDiscoveryService.StreamAggregatedResources</p></li>
<li><p>Incremental: AggregatedDiscoveryService.DeltaAggregatedResources</p></li>
</ul>
<p>For all of the SotW methods, the request type is <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> and the response type is <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>.</p>
<p>For all of the incremental methods, the request type is <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a> and the response type is <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryresponse"><span class="std std-ref">DeltaDiscoveryResponse</span></a>.</p>
</div>
<div class="section" id="configuring-which-variant-to-use">
<h4>Configuring Which Variant to Use<a class="headerlink" href="#configuring-which-variant-to-use" title="Permalink to this headline">¶</a></h4>
<p>In the xDS API, the <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-configsource"><span class="std std-ref">ConfigSource</span></a> message indicates how to
obtain resources of a particular type. If the <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-configsource"><span class="std std-ref">ConfigSource</span></a>
contains a gRPC <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-apiconfigsource"><span class="std std-ref">ApiConfigSource</span></a>, it points to an
upstream cluster for the management server; this will initiate an independent bidirectional gRPC
stream for each xDS resource type, potentially to distinct management servers. If the
<a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-configsource"><span class="std std-ref">ConfigSource</span></a> contains a <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-aggregatedconfigsource"><span class="std std-ref">AggregatedConfigSource</span></a>, it tells the client to use <a class="reference internal" href="#xds-protocol-ads"><span class="std std-ref">ADS</span></a>.</p>
<p>Currently, the client is expected to be given some local configuration that tells it how to obtain
the <a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a> resources.
<a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> resources may include a
<a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-configsource"><span class="std std-ref">ConfigSource</span></a> that indicates how the
<a class="reference internal" href="../api-v3/config/route/v3/route.proto.html#envoy-v3-api-msg-config-route-v3-routeconfiguration"><span class="std std-ref">RouteConfiguration</span></a> resources are obtained, and
<a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a> resources may include a
<a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-configsource"><span class="std std-ref">ConfigSource</span></a> that indicates how the
<a class="reference internal" href="../api-v3/config/endpoint/v3/endpoint.proto.html#envoy-v3-api-msg-config-endpoint-v3-clusterloadassignment"><span class="std std-ref">ClusterLoadAssignment</span></a> resources are obtained.</p>
<div class="section" id="client-configuration">
<h5>Client Configuration<a class="headerlink" href="#client-configuration" title="Permalink to this headline">¶</a></h5>
<p>In Envoy, the bootstrap file contains two <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-configsource"><span class="std std-ref">ConfigSource</span></a>
messages, one indicating how <a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> resources are obtained and
another indicating how <a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a> resources are obtained. It also
contains a separate <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-apiconfigsource"><span class="std std-ref">ApiConfigSource</span></a> message indicating
how to contact the ADS server, which will be used whenever a <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-configsource"><span class="std std-ref">ConfigSource</span></a> message (either in the bootstrap file or in a <a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> or <a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a> resource obtained from a
management server) contains an <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-aggregatedconfigsource"><span class="std std-ref">AggregatedConfigSource</span></a> message.</p>
<p>In a gRPC client that uses xDS, only ADS is supported, and the bootstrap file contains the name of
the ADS server, which will be used for all resources. The <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-configsource"><span class="std std-ref">ConfigSource</span></a> messages in the <a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> and
<a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a> resources must contain <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-aggregatedconfigsource"><span class="std std-ref">AggregatedConfigSource</span></a> messages.</p>
</div>
</div>
</div>
<div class="section" id="the-xds-transport-protocol">
<h3>The xDS transport Protocol<a class="headerlink" href="#the-xds-transport-protocol" title="Permalink to this headline">¶</a></h3>
<div class="section" id="transport-api-version">
<h4>Transport API version<a class="headerlink" href="#transport-api-version" title="Permalink to this headline">¶</a></h4>
<p>In addition the resource type version described above, the xDS wire protocol has a
transport version associated with it. This provides type versioning for messages such as
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> and <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>. It is also encoded in the gRPC method name, so a server
can determine which version a client is speaking based on which method it calls.</p>
</div>
<div class="section" id="basic-protocol-overview">
<h4>Basic Protocol Overview<a class="headerlink" href="#basic-protocol-overview" title="Permalink to this headline">¶</a></h4>
<p>Each xDS stream begins with a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> from the
client, which specifies the list of resources to subscribe to, the type URL corresponding to the
subscribed resources, the node identifier, and an optional resource type instance version
indicating the most recent version of the resource type that the client has already seen (see
<a class="reference internal" href="#xds-ack-nack"><span class="std std-ref">ACK/NACK and resource type instance version</span></a> for details).</p>
<p>The server will then send a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> containing
any resources that the client has subscribed to that have changed since the last resource type
instance version that the client indicated it has seen. The server may send additional responses
at any time when the subscribed resources change.</p>
<p>Whenever the client receives a new response, it will send another request indicating whether or
not the resources in the response were valid (see
<a class="reference internal" href="#xds-ack-nack"><span class="std std-ref">ACK/NACK and resource type instance version</span></a> for details).</p>
<p>All server responses will contain a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryresponse-nonce"><span class="std std-ref">nonce</span></a>, and
all subsequent requests from the client must set the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-response-nonce"><span class="std std-ref">response_nonce</span></a> field to the most recent
nonce received from the server on that stream. This allows servers to determine which response a
given request is associated with, which avoids various race conditions in the SotW protocol
variants. Note that the nonce is valid only in the context of an individual xDS stream; it does
not survive stream restarts.</p>
<p>Only the first request on a stream is guaranteed to carry the node identifier.
The subsequent discovery requests on the same stream may carry an empty node
identifier. This holds true regardless of the acceptance of the discovery
responses on the same stream. The node identifier should always be identical if
present more than once on the stream. It is sufficient to only check the first
message for the node identifier as a result.</p>
</div>
<div class="section" id="ack-nack-and-resource-type-instance-version">
<span id="xds-ack-nack"></span><h4>ACK/NACK and resource type instance version<a class="headerlink" href="#ack-nack-and-resource-type-instance-version" title="Permalink to this headline">¶</a></h4>
<p>Every xDS resource type has a version string that indicates the version for that resource type.
Whenever one resource of that type changes, the version is changed.</p>
<p>In a response sent by the xDS server, the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryresponse-version-info"><span class="std std-ref">version_info</span></a> field indicates the current
version for that resource type. The client then sends another request to the server with the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-version-info"><span class="std std-ref">version_info</span></a> field indicating the most
recent valid version seen by the client. This provides a way for the server to determine when
it sends a version that the client considers invalid.</p>
<p>(In the <a class="reference internal" href="#xds-protocol-delta"><span class="std std-ref">incremental protocol variants</span></a>, the resource type instance
version is sent by the server in the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryresponse-system-version-info"><span class="std std-ref">system_version_info</span></a> field.
However, this information is not actually used by the client to communicate which resources are
valid, because the incremental API variants have a separate mechanism for that.)</p>
<p>The resource type instance version is separate for each resource type. When using the aggregated
protocol variants, each resource type has its own version even though all resource types are being
sent on the same stream.</p>
<p>The resource type instance version is also separate for each xDS server (where an xDS server is
identified by a unique <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-configsource"><span class="std std-ref">ConfigSource</span></a>). When obtaining
resources of a given type from multiple xDS servers, each xDS server will have a different notion
of version.</p>
<p>Note that the version for a resource type is not a property of an individual xDS stream but rather
a property of the resources themselves. If the stream becomes broken and the client creates a new
stream, the client’s initial request on the new stream should indicate the most recent version
seen by the client on the previous stream. Servers may decide to optimize by not resending
resources that the client had already seen on the previous stream, but only if they know that the
client is not subscribing to a new resource that it was not previously subscribed to. For example,
it is generally safe for servers to do this optimization for LDS and CDS when the only subscription
is a wildcard subscription, and it is safe to do in environments where the clients will always
subscribe to exactly the same set of resources.</p>
<p>An example EDS request might be:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">version_info</span><span class="p">:</span><span class="w"></span>
<span class="nt">node</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> id</span><span class="p">:</span><span class="w"> </span><span class="nv">envoy</span><span class="w"> </span><span class="p p-Indicator">}</span><span class="w"></span>
<span class="nt">resource_names</span><span class="p">:</span><span class="w"></span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">foo</span><span class="w"></span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">bar</span><span class="w"></span>
<span class="nt">type_url</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment</span><span class="w"></span>
<span class="nt">response_nonce</span><span class="p">:</span><span class="w"></span>
</pre></div>
</div>
<p>The management server may reply either immediately or when the requested
resources are available with a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>, e.g.:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">version_info</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">X</span><span class="w"></span>
<span class="nt">resources</span><span class="p">:</span><span class="w"></span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">foo ClusterLoadAssignment proto encoding</span><span class="w"></span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">bar ClusterLoadAssignment proto encoding</span><span class="w"></span>
<span class="nt">type_url</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment</span><span class="w"></span>
<span class="nt">nonce</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">A</span><span class="w"></span>
</pre></div>
</div>
<p>After processing the <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>, Envoy will send a new
request on the stream, specifying the last version successfully applied
and the nonce provided by the management server. The version provides Envoy and the
management server a shared notion of the currently applied configuration,
as well as a mechanism to ACK/NACK configuration updates.</p>
</div>
<div class="section" id="ack">
<h4>ACK<a class="headerlink" href="#ack" title="Permalink to this headline">¶</a></h4>
<p>If the update was successfully applied, the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-version-info"><span class="std std-ref">version_info</span></a> will be <strong>X</strong>, as indicated
in the sequence diagram:</p>
<div class="figure align-default">
<img alt="Version update after ACK" src="../_images/simple-ack.svg" /></div>
</div>
<div class="section" id="nack">
<h4>NACK<a class="headerlink" href="#nack" title="Permalink to this headline">¶</a></h4>
<p>If Envoy had instead rejected configuration
update <strong>X</strong>, it would reply with <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-error-detail"><span class="std std-ref">error_detail</span></a>
populated and its previous version, which in this case was the empty
initial version. The <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-error-detail"><span class="std std-ref">error_detail</span></a> has
more details around the exact error message populated in the message field:</p>
<div class="figure align-default">
<img alt="No version update after NACK" src="../_images/simple-nack.svg" /></div>
<p>In the sequence diagrams, the following format is used to abbreviate messages:</p>
<ul class="simple">
<li><p><em>DiscoveryRequest</em>: (V=version_info,R=resource_names,N=response_nonce,T=type_url)</p></li>
<li><p><em>DiscoveryResponse</em>: (V=version_info,R=resources,N=nonce,T=type_url)</p></li>
</ul>
<p>After a NACK, an API update may succeed at a new version <strong>Y</strong>:</p>
<div class="figure align-default">
<img alt="ACK after NACK" src="../_images/later-ack.svg" /></div>
<p>The preferred mechanism for a server to detect a NACK is to look for the presence of the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-error-detail"><span class="std std-ref">error_detail</span></a> field in the request sent by
the client. Some older servers may instead detect a NACK by looking at both the version and the
nonce in the request: if the version in the request is not equal to the one sent by the server with
that nonce, then the client has rejected the most recent version. However, this approach does not
work for APIs other than LDS and CDS for clients that may dynamically change the set of resources
that they are subscribing to, unless the server has somehow arranged to increment the resource
type instance version every time any one client subscribes to a new resource. Specifically,
consider the following example:</p>
<div class="figure align-default">
<img alt="detecting NACK from error_detail instead of version and nonce" src="../_images/error-detail-nack.svg" /></div>
</div>
<div class="section" id="ack-and-nack-semantics-summary">
<h4>ACK and NACK semantics summary<a class="headerlink" href="#ack-and-nack-semantics-summary" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>The xDS client should ACK or NACK every <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>
received from the management server. The <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-response-nonce"><span class="std std-ref">response_nonce</span></a> field tells the server which of its responses
the ACK or NACK is associated with.</p></li>
<li><p>ACK signifies successful configuration update and contains the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryresponse-version-info"><span class="std std-ref">version_info</span></a> from the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>.</p></li>
<li><p>NACK signifies unsuccessful configuration and is indicated by the presence of the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-error-detail"><span class="std std-ref">error_detail</span></a> field. The <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryresponse-version-info"><span class="std std-ref">version_info</span></a> indicates the most recent version that the
client is using, although that may not be an older version in the case where the client has
subscribed to a new resource from an existing version and that new resource is invalid (see
example above).</p></li>
</ul>
</div>
<div class="section" id="when-to-send-an-update">
<span id="xds-protocol-resource-update"></span><h4>When to send an update<a class="headerlink" href="#when-to-send-an-update" title="Permalink to this headline">¶</a></h4>
<p>The management server should only send updates to the Envoy client when
the resources in the <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> have changed. Envoy replies
to any <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> with a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> containing the
ACK/NACK immediately after it has been either accepted or rejected. If
the management server provides the same set of resources rather than
waiting for a change to occur, it will cause needless work on both the client and the management
server, which could have a severe performance impact.</p>
<p>Within a stream, new <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequests</span></a> supersede any prior
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequests</span></a> having the same resource type. This means that
the management server only needs to respond to the latest
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> on each stream for any given resource type.</p>
</div>
<div class="section" id="how-the-client-specifies-what-resources-to-return">
<span id="xds-protocol-resource-hints"></span><h4>How the client specifies what resources to return<a class="headerlink" href="#how-the-client-specifies-what-resources-to-return" title="Permalink to this headline">¶</a></h4>
<p>xDS requests allow the client to specify a set of resource names as a hint to the server about
which resources the client is interested in. In the SotW protocol variants, this is done via the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> specified in the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a>; in the incremental protocol variants,
this is done via the <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a> and
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-unsubscribe"><span class="std std-ref">resource_names_unsubscribe</span></a> fields in the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a>.</p>
<p>Normally (see below for exceptions), requests must specify the set of resource names that the
client is interested in. The management server must supply the requested resources if they exist.
The client will silently ignore any supplied resources that were not explicitly requested. When
the client sends a new request that changes the set of resources being requested, the server must
resend any newly requested resources, even if it previously sent those resources without having
been asked for them and the resources have not changed since that time. If the list of resource
names becomes empty, that means that the client is no longer interested in any resources of the
specified type.</p>
<p>For <a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a> resource
types, there is also a “wildcard” subscription, which is triggered when subscribing to the special
name “*”. In this case, the server should use site-specific business logic to determine the full
set of resources that the client is interested in, typically based on the client’s
<a class="reference internal" href="../api-v3/config/core/v3/base.proto.html#envoy-v3-api-msg-config-core-v3-node"><span class="std std-ref">node</span></a> identification.</p>
<p>For historical reasons, if the client sends a request for a given resource type but has never
explicitly subscribed to any resource names (i.e., in SotW, all requests on the stream for that
resource type have had an empty <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a>
field, or in incremental, having never sent a request on the stream for that resource type with a
non-empty <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a>
field), the server should treat that identically to how it would treat the client having
explicitly subscribed to “*”. However, once the client does explicitly subscribe to a resource
name (whether it be “*” or any other name), then this legacy semantic is no longer available; at
that point, clearing the list of subscribed resources is interpretted as an unsubscription (see
<a class="reference internal" href="#xds-protocol-unsubscribing"><span class="std std-ref">Unsubscribing From Resources</span></a>) rather than as a subscription
to “*”.</p>
<p>For example, in SotW:</p>
<ul class="simple">
<li><p>Client sends a request with <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> unset. Server interprets this as a subscription to “*”.</p></li>
<li><p>Client sends a request with <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> set to “*” and “A”. Server interprets this as continuing the existing subscription to “*” and adding a new subscription to “A”.</p></li>
<li><p>Client sends a request with <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> set to “A”. Server interprets this as unsubscribing to “*” and continuing the existing subscription to “A”.</p></li>
<li><p>Client sends a request with <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> unset. Server interprets this as unsubscribing to “A” (i.e., the client has now unsubscribed to all resources). Although this request is identical to the first one, it is not interpreted as a wildcard subscription, because there has previously been a request on this stream for this resource type that set the <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> field.</p></li>
</ul>
<p>And in incremental:</p>
<ul class="simple">
<li><p>Client sends a request with <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a> unset. Server interprets this as a subscription to “*”.</p></li>
<li><p>Client sends a request with <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a> set to “A”. Server interprets this as continuing the existing subscription to “*” and adding a new subscription to “A”.</p></li>
<li><p>Client sends a request with <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-unsubscribe"><span class="std std-ref">resource_names_unsubscribe</span></a> set to “*”. Server interprets this as unsubscribing to “*” and continuing the existing subscription to “A”.</p></li>
<li><p>Client sends a request with <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-unsubscribe"><span class="std std-ref">resource_names_unsubscribe</span></a> set to “A”. Server interprets this as unsubscribing to “A” (i.e., the client has now unsubscribed to all resources). Although the set of subscribed resources is now empty, just as it was after the initial request, it is not interpreted as a wildcard subscription, because there has previously been a request on this stream for this resource type that set the <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a> field.</p></li>
</ul>
<div class="section" id="client-behavior">
<h5>Client Behavior<a class="headerlink" href="#client-behavior" title="Permalink to this headline">¶</a></h5>
<p>Envoy will always use wildcard subscriptions for <a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> and
<a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a> resources. However, other xDS clients (such as gRPC clients
that use xDS) may explicitly subscribe to specific resource names for these resource types, for example if they
only have a singleton listener and already know its name from some out-of-band configuration.</p>
</div>
</div>
<div class="section" id="grouping-resources-into-responses">
<h4>Grouping Resources into Responses<a class="headerlink" href="#grouping-resources-into-responses" title="Permalink to this headline">¶</a></h4>
<p>In the incremental protocol variants, the server sends each resource in its own response. This
means that if the server has previously sent 100 resources and only one of them has changed, it
may send a response containing only the changed resource; it does not need to resend the 99
resources that have not changed, and the client must not delete the unchanged resources.</p>
<p>In the SotW protocol variants, all resource types except for <a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a> are grouped into responses
in the same way as in the incremental protocol variants. However,
<a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a> resource types
are handled differently: the server must include the complete state of the world, meaning that all
resources of the relevant type that are needed by the client must be included, even if they did
not change since the last response. This means that if the server has previously sent 100
resources and only one of them has changed, it must resend all 100 of them, even the 99 that were
not modified.</p>
<p>Note that all of the protocol variants operate on units of whole named resources. There is
no mechanism for providing incremental updates of repeated fields within a named resource.
Most notably, there is currently no mechanism for incrementally updating individual
endpoints within an EDS response.</p>
</div>
<div class="section" id="duplicate-resource-names">
<h4>Duplicate Resource Names<a class="headerlink" href="#duplicate-resource-names" title="Permalink to this headline">¶</a></h4>
<p>It is an error for a server to send a single response that contains the same resource name
twice. Clients should NACK responses that contain multiple instances of the same resource name.</p>
</div>
<div class="section" id="deleting-resources">
<h4>Deleting Resources<a class="headerlink" href="#deleting-resources" title="Permalink to this headline">¶</a></h4>
<p>In the incremental protocol variants, the server signals the client that a resource should be
deleted via the <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryresponse-removed-resources"><span class="std std-ref">removed_resources</span></a>
field of the response. This tells the client to remove the resource from its local cache.</p>
<p>In the SotW protocol variants, the criteria for deleting resources is more complex. For
<a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a> resource types,
if a previously seen resource is not present in a new response, that indicates that the resource
has been removed, and the client must delete it; a response containing no resources means to delete
all resources of that type. However, for other resource types, the API provides no mechanism for
the server to tell the client that resources have been deleted; instead, deletions are indicated
implicitly by parent resources being changed to no longer refer to a child resource. For example,
when the client receives an LDS update removing a <a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a>
that was previously pointing to <a class="reference internal" href="../api-v3/config/route/v3/route.proto.html#envoy-v3-api-msg-config-route-v3-routeconfiguration"><span class="std std-ref">RouteConfiguration</span></a> A,
if no other <a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> is pointing to <a class="reference internal" href="../api-v3/config/route/v3/route.proto.html#envoy-v3-api-msg-config-route-v3-routeconfiguration"><span class="std std-ref">RouteConfiguration</span></a> A, then the client may delete A. For those resource types,
an empty <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> is effectively a no-op
from the client’s perspective.</p>
</div>
<div class="section" id="knowing-when-a-requested-resource-does-not-exist">
<span id="xds-protocol-resource-not-existed"></span><h4>Knowing When a Requested Resource Does Not Exist<a class="headerlink" href="#knowing-when-a-requested-resource-does-not-exist" title="Permalink to this headline">¶</a></h4>
<p>The SotW protocol variants do not provide any explicit mechanism to determine when a requested
resource does not exist.</p>
<p>Responses for <a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a>
resource types must include all resources requested by the client. However, it may not be possible
for the client to know that a resource does not exist based solely on its absence in a response,
because the delivery of the updates is eventually consistent: if the client initially sends a
request for resource A, then sends a request for resources A and B, and then sees a response
containing only resource A, the client cannot conclude that resource B does not exist, because
the response may have been sent on the basis of the first request, before the server saw the
second request.</p>
<p>For other resource types, because each resource can be sent in its own response, there is no way
to know from the next response whether the newly requested resource exists, because the next
response could be an unrelated update for another resource that had already been subscribed to
previously.</p>
<p>As a result, clients are expected to use a timeout (recommended duration is 15 seconds) after
sending a request for a new resource, after which they will consider the requested resource to
not exist if they have not received the resource. In Envoy, this is done for
<a class="reference internal" href="../api-v3/config/route/v3/route.proto.html#envoy-v3-api-msg-config-route-v3-routeconfiguration"><span class="std std-ref">RouteConfiguration</span></a> and <a class="reference internal" href="../api-v3/config/endpoint/v3/endpoint.proto.html#envoy-v3-api-msg-config-endpoint-v3-clusterloadassignment"><span class="std std-ref">ClusterLoadAssignment</span></a> resources during <a class="reference internal" href="#xds-protocol-resource-warming"><span class="std std-ref">resource warming</span></a>.</p>
<p>Note that even if a requested resource does not exist at the moment when the client requests it,
that resource could be created at any time. Management servers must remember the set of resources
being requested by the client, and if one of those resources springs into existence later, the
server must send an update to the client informing it of the new resource. Clients that initially
see a resource that does not exist must be prepared for the resource to be created at any time.</p>
</div>
<div class="section" id="unsubscribing-from-resources">
<span id="xds-protocol-unsubscribing"></span><h4>Unsubscribing From Resources<a class="headerlink" href="#unsubscribing-from-resources" title="Permalink to this headline">¶</a></h4>
<p>In the incremental protocol variants, resources can be unsubscribed to via the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-unsubscribe"><span class="std std-ref">resource_names_unsubscribe</span></a> field.</p>
<p>In the SotW protocol variants, each request must contain the full list of resource names being
subscribed to in the <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> field,
so unsubscribing to a set of resources is done by sending a new request containing all resource
names that are still being subscribed to but not containing the resource names being unsubscribed
to. For example, if the client had previously been subscribed to resources A and B but wishes to
unsubscribe from B, it must send a new request containing only resource A.</p>
<p>Note that for <a class="reference internal" href="../api-v3/config/listener/v3/listener.proto.html#envoy-v3-api-msg-config-listener-v3-listener"><span class="std std-ref">Listener</span></a> and <a class="reference internal" href="../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">Cluster</span></a>
resource types where the client is using a “wildcard” subscription (see <a class="reference internal" href="#xds-protocol-resource-hints"><span class="std std-ref">How the client specifies what
resources to return</span></a> for details), the set of resources being
subscribed to is determined by the server instead of the client, so the client cannot unsubscribe
from those resources individually; it can only unsubscribe from the wildcard as a whole.</p>
</div>
<div class="section" id="requesting-multiple-resources-on-a-single-stream">
<h4>Requesting Multiple Resources on a Single Stream<a class="headerlink" href="#requesting-multiple-resources-on-a-single-stream" title="Permalink to this headline">¶</a></h4>
<p>For EDS/RDS, Envoy may either generate a distinct stream for each
resource of a given type (e.g. if each <a class="reference internal" href="../api-v3/config/core/v3/config_source.proto.html#envoy-v3-api-msg-config-core-v3-configsource"><span class="std std-ref">ConfigSource</span></a> has its own
distinct upstream cluster for a management server), or may combine
together multiple resource requests for a given resource type when they
are destined for the same management server. While this is left to
implementation specifics, management servers should be capable of
handling one or more <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> for a given resource type in
each request. Both sequence diagrams below are valid for fetching two
EDS resources <code class="docutils literal notranslate"><span class="pre">{foo,</span> <span class="pre">bar}</span></code>:</p>
<p><img alt="Multiple EDS requests on the same stream" src="../_images/eds-same-stream.svg" /> <img alt="Multiple EDS requests on distinct streams" src="../_images/eds-distinct-stream.svg" /></p>
</div>
<div class="section" id="resource-updates">
<h4>Resource updates<a class="headerlink" href="#resource-updates" title="Permalink to this headline">¶</a></h4>
<p>As discussed above, Envoy may update the list of <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> it
presents to the management server in each <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> that
ACK/NACKs a specific <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>. In addition, Envoy may later
issue additional <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequests</span></a> at a given <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-version-info"><span class="std std-ref">version_info</span></a> to
update the management server with new resource hints. For example, if
Envoy is at EDS version <strong>X</strong> and knows only about cluster <code class="docutils literal notranslate"><span class="pre">foo</span></code>, but
then receives a CDS update and learns about <code class="docutils literal notranslate"><span class="pre">bar</span></code> in addition, it may
issue an additional <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> for <strong>X</strong> with <code class="docutils literal notranslate"><span class="pre">{foo,bar}</span></code> as
<code class="docutils literal notranslate"><span class="pre">resource_names</span></code>.</p>
<div class="figure align-default">
<img alt="CDS response leads to EDS resource hint update" src="../_images/cds-eds-resources.svg" /></div>
<p>There is a race condition that may arise here; if after a resource hint
update is issued by Envoy at <strong>X</strong>, but before the management server
processes the update it replies with a new version <strong>Y</strong>, the resource
hint update may be interpreted as a rejection of <strong>Y</strong> by presenting an
<strong>X</strong> <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryresponse-version-info"><span class="std std-ref">version_info</span></a>. To avoid this, the management server provides a
<code class="docutils literal notranslate"><span class="pre">nonce</span></code> that Envoy uses to indicate the specific <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>
each <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> corresponds to:</p>
<div class="figure align-default">
<img alt="EDS update race motivates nonces" src="../_images/update-race.svg" /></div>
<p>The management server should not send a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> for any
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> that has a stale nonce. A nonce becomes stale
following a newer nonce being presented to Envoy in a
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>. A management server does not need to send an
update until it determines a new version is available. Earlier requests
at a version then also become stale. It may process multiple
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequests</span></a> at a version until a new version is ready.</p>
<div class="figure align-default">
<img alt="Requests become stale" src="../_images/stale-requests.svg" /></div>
<p>An implication of the above resource update sequencing is that Envoy
does not expect a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> for every <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequests</span></a>
it issues.</p>
</div>
</div>
<div class="section" id="resource-warming">
<span id="xds-protocol-resource-warming"></span><h3>Resource warming<a class="headerlink" href="#resource-warming" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../intro/arch_overview/upstream/cluster_manager.html#arch-overview-cluster-warming"><span class="std std-ref">Clusters</span></a> and
<a class="reference internal" href="../configuration/listeners/lds.html#config-listeners-lds"><span class="std std-ref">Listeners</span></a>
go through warming before they can serve requests. This process
happens both during <a class="reference internal" href="../intro/arch_overview/operations/init.html#arch-overview-initialization"><span class="std std-ref">Envoy initialization</span></a>
and when the <code class="docutils literal notranslate"><span class="pre">Cluster</span></code> or <code class="docutils literal notranslate"><span class="pre">Listener</span></code> is updated. Warming of
<code class="docutils literal notranslate"><span class="pre">Cluster</span></code> is completed only when a <code class="docutils literal notranslate"><span class="pre">ClusterLoadAssignment</span></code> response
is supplied by management server. Similarly, warming of <code class="docutils literal notranslate"><span class="pre">Listener</span></code> is
completed only when a <code class="docutils literal notranslate"><span class="pre">RouteConfiguration</span></code> is supplied by management
server if the listener refers to an RDS configuration. Management server
is expected to provide the EDS/RDS updates during warming. If management
server does not provide EDS/RDS responses, Envoy will not initialize
itself during the initialization phase and the updates sent via CDS/LDS
will not take effect until EDS/RDS responses are supplied.</p>
<div class="section" id="eventual-consistency-considerations">
<span id="xds-protocol-eventual-consistency-considerations"></span><h4>Eventual consistency considerations<a class="headerlink" href="#eventual-consistency-considerations" title="Permalink to this headline">¶</a></h4>
<p>Since Envoy’s xDS APIs are eventually consistent, traffic may drop
briefly during updates. For example, if only cluster <strong>X</strong> is known via
CDS/EDS, a <code class="docutils literal notranslate"><span class="pre">RouteConfiguration</span></code> references cluster <strong>X</strong> and is then
adjusted to cluster <strong>Y</strong> just before the CDS/EDS update providing
<strong>Y</strong>, traffic will be blackholed until <strong>Y</strong> is known about by the
Envoy instance.</p>
<p>For some applications, a temporary drop of traffic is acceptable,
retries at the client or by other Envoy sidecars will hide this drop.
For other scenarios where drop can’t be tolerated, traffic drop could
have been avoided by providing a CDS/EDS update with both <strong>X</strong> and
<strong>Y</strong>, then the RDS update repointing from <strong>X</strong> to <strong>Y</strong> and then a
CDS/EDS update dropping <strong>X</strong>.</p>
<p>In general, to avoid traffic drop, sequencing of updates should follow a
make before break model, wherein:</p>
<ul class="simple">
<li><p>CDS updates (if any) must always be pushed first.</p></li>
<li><p>EDS updates (if any) must arrive after CDS updates for the respective clusters.</p></li>
<li><p>LDS updates must arrive after corresponding CDS/EDS updates.</p></li>
<li><p>RDS updates related to the newly added listeners must arrive after CDS/EDS/LDS updates.</p></li>
<li><p>VHDS updates (if any) related to the newly added RouteConfigurations must arrive after RDS updates.</p></li>
<li><p>Stale CDS clusters and related EDS endpoints (ones no longer being referenced) can then be removed.</p></li>
</ul>
<p>xDS updates can be pushed independently if no new
clusters/routes/listeners are added or if it’s acceptable to temporarily
drop traffic during updates. Note that in case of LDS updates, the
listeners will be warmed before they receive traffic, i.e. the dependent
routes are fetched through RDS if configured. Clusters are warmed when
adding/removing/updating clusters. On the other hand, routes are not
warmed, i.e., the management plane must ensure that clusters referenced
by a route are in place, before pushing the updates for a route.</p>
</div>
</div>
<div class="section" id="ttl">
<span id="xds-protocol-ttl"></span><h3>TTL<a class="headerlink" href="#ttl" title="Permalink to this headline">¶</a></h3>
<p>In the event that the management server becomes unreachable, the last known configuration received
by Envoy will persist until the connection is reestablished. For some services, this may not be
desirable. For example, in the case of a fault injection service, a management server crash at the
wrong time may leave Envoy in an undesirable state. The TTL setting allows Envoy to remove a set of
resources after a specified period of time if contact with the management server is lost. This can
be used, for example, to terminate a fault injection test when the management server can no longer
be reached.</p>
<p>For clients that support the <em>xds.config.supports-resource-ttl</em> client feature, A TTL field may
be specified on each <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-resource"><span class="std std-ref">Resource</span></a>. Each resource will have its own TTL
expiry time, at which point the resource will be expired. Each xDS type may have different ways of
handling such an expiry.</p>
<p>To update the TTL associated with a <em>Resource</em>, the management server resends the resource with a
new TTL. To remove the TTL, the management server resends the resource with the TTL field unset.</p>
<p>To allow for lightweight TTL updates (“heartbeats”), a response can be sent that provides a
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-resource"><span class="std std-ref">Resource</span></a> with the <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-resource"><span class="std std-ref">resource</span></a>
unset and version matching the most recently sent version can be used to update the TTL. These
resources will not be treated as resource updates, but only as TTL updates.</p>
<div class="section" id="sotw-ttl">
<h4>SotW TTL<a class="headerlink" href="#sotw-ttl" title="Permalink to this headline">¶</a></h4>
<p>In order to use TTL with SotW xDS, the relevant resources must be wrapped in a
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-resource"><span class="std std-ref">Resource</span></a>. This allows setting the same TTL field that is used for
Delta xDS with SotW, without changing the SotW API. Heartbeats are supported for SotW as well:
any resource within the response that look like a heartbeat resource will only be used to update the TTL.</p>
<p>This feature is gated by the <em>xds.config.supports-resource-in-sotw</em> client feature.</p>
</div>
</div>
<div class="section" id="aggregated-discovery-service">
<span id="xds-protocol-ads"></span><h3>Aggregated Discovery Service<a class="headerlink" href="#aggregated-discovery-service" title="Permalink to this headline">¶</a></h3>
<p>It’s challenging to provide the above guarantees on sequencing to avoid
traffic drop when management servers are distributed. ADS allow a single
management server, via a single gRPC stream, to deliver all API updates.
This provides the ability to carefully sequence updates to avoid traffic
drop. With ADS, a single stream is used with multiple independent
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a>/<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> sequences multiplexed via the
type URL. For any given type URL, the above sequencing of
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> and <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> messages applies. An
example update sequence might look like:</p>
<div class="figure align-default">
<img alt="EDS/CDS multiplexed on an ADS stream" src="../_images/ads.svg" /></div>
<p>A single ADS stream is available per Envoy instance.</p>
<p>An example minimal <code class="docutils literal notranslate"><span class="pre">bootstrap.yaml</span></code> fragment for ADS configuration is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">node</span><span class="p">:</span>
  <span class="c1"># set &lt;cluster identifier&gt;</span>
  <span class="n">cluster</span><span class="p">:</span> <span class="n">envoy_cluster</span>
  <span class="c1"># set &lt;node identifier&gt;</span>
  <span class="nb">id</span><span class="p">:</span> <span class="n">envoy_node</span>

<span class="n">dynamic_resources</span><span class="p">:</span>
  <span class="n">ads_config</span><span class="p">:</span>
    <span class="n">api_type</span><span class="p">:</span> <span class="n">GRPC</span>
    <span class="n">transport_api_version</span><span class="p">:</span> <span class="n">V3</span>
    <span class="n">grpc_services</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">envoy_grpc</span><span class="p">:</span>
        <span class="n">cluster_name</span><span class="p">:</span> <span class="n">ads_cluster</span>
  <span class="n">cds_config</span><span class="p">:</span>
    <span class="n">resource_api_version</span><span class="p">:</span> <span class="n">V3</span>
    <span class="n">ads</span><span class="p">:</span> <span class="p">{}</span>
  <span class="n">lds_config</span><span class="p">:</span>
    <span class="n">resource_api_version</span><span class="p">:</span> <span class="n">V3</span>
    <span class="n">ads</span><span class="p">:</span> <span class="p">{}</span>

<span class="n">static_resources</span><span class="p">:</span>
  <span class="n">clusters</span><span class="p">:</span>
  <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">ads_cluster</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">STRICT_DNS</span>
    <span class="n">load_assignment</span><span class="p">:</span>
      <span class="n">cluster_name</span><span class="p">:</span> <span class="n">ads_cluster</span>
      <span class="n">endpoints</span><span class="p">:</span>
      <span class="o">-</span> <span class="n">lb_endpoints</span><span class="p">:</span>
        <span class="o">-</span> <span class="n">endpoint</span><span class="p">:</span>
            <span class="n">address</span><span class="p">:</span>
              <span class="n">socket_address</span><span class="p">:</span>
                <span class="c1"># set &lt;ADS management server address&gt;</span>
                <span class="n">address</span><span class="p">:</span> <span class="n">my</span><span class="o">-</span><span class="n">control</span><span class="o">-</span><span class="n">plane</span>
                <span class="c1"># set &lt;ADS management server port&gt;</span>
                <span class="n">port_value</span><span class="p">:</span> <span class="mi">777</span>
    <span class="c1"># It is recommended to configure either HTTP/2 or TCP keepalives in order to detect</span>
    <span class="c1"># connection issues, and allow Envoy to reconnect. TCP keepalive is less expensive, but</span>
    <span class="c1"># may be inadequate if there is a TCP proxy between Envoy and the management server.</span>
    <span class="c1"># HTTP/2 keepalive is slightly more expensive, but may detect issues through more types</span>
    <span class="c1"># of intermediate proxies.</span>
    <span class="n">typed_extension_protocol_options</span><span class="p">:</span>
      <span class="n">envoy</span><span class="o">.</span><span class="n">extensions</span><span class="o">.</span><span class="n">upstreams</span><span class="o">.</span><span class="n">http</span><span class="o">.</span><span class="n">v3</span><span class="o">.</span><span class="n">HttpProtocolOptions</span><span class="p">:</span>
        <span class="s2">&quot;@type&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="o">.</span><span class="n">googleapis</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">envoy</span><span class="o">.</span><span class="n">extensions</span><span class="o">.</span><span class="n">upstreams</span><span class="o">.</span><span class="n">http</span><span class="o">.</span><span class="n">v3</span><span class="o">.</span><span class="n">HttpProtocolOptions</span>
        <span class="n">explicit_http_config</span><span class="p">:</span>
          <span class="n">http2_protocol_options</span><span class="p">:</span>
            <span class="n">connection_keepalive</span><span class="p">:</span>
              <span class="n">interval</span><span class="p">:</span> <span class="mi">30</span><span class="n">s</span>
              <span class="n">timeout</span><span class="p">:</span> <span class="mi">5</span><span class="n">s</span>
    <span class="n">upstream_connection_options</span><span class="p">:</span>
      <span class="n">tcp_keepalive</span><span class="p">:</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
<div class="section" id="incremental-xds">
<span id="xds-protocol-delta"></span><h3>Incremental xDS<a class="headerlink" href="#incremental-xds" title="Permalink to this headline">¶</a></h3>
<p>Incremental xDS is a separate xDS endpoint that:</p>
<ul class="simple">
<li><p>Allows the protocol to communicate on the wire in terms of
resource/resource name deltas (“Delta xDS”). This supports the goal
of scalability of xDS resources. Rather than deliver all 100k
clusters when a single cluster is modified, the management server
only needs to deliver the single cluster that changed.</p></li>
<li><p>Allows the Envoy to on-demand / lazily request additional resources.
For example, requesting a cluster only when a request for that
cluster arrives.</p></li>
</ul>
<p>An Incremental xDS session is always in the context of a gRPC
bidirectional stream. This allows the xDS server to keep track of the
state of xDS clients connected to it. There is no REST version of
Incremental xDS yet.</p>
<p>In the delta xDS wire protocol, the nonce field is required and used to
pair a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryresponse"><span class="std std-ref">DeltaDiscoveryResponse</span></a>
to a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a>
ACK or NACK. Optionally, a response message level <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryresponse-system-version-info"><span class="std std-ref">system_version_info</span></a>
is present for debugging purposes only.</p>
<p><a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a> can be sent in the following situations:</p>
<ul class="simple">
<li><p>Initial message in a xDS bidirectional gRPC stream.</p></li>
<li><p>As an ACK or NACK response to a previous <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryresponse"><span class="std std-ref">DeltaDiscoveryResponse</span></a>. In this case the <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-response-nonce"><span class="std std-ref">response_nonce</span></a> is set to the nonce value in the Response. ACK or NACK is determined by the absence or presence of <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-error-detail"><span class="std std-ref">error_detail</span></a>.</p></li>
<li><p>Spontaneous <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequests</span></a> from the client. This can be done to dynamically add or remove elements from the tracked <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-resource-names"><span class="std std-ref">resource_names</span></a> set. In this case <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-response-nonce"><span class="std std-ref">response_nonce</span></a> must be omitted.</p></li>
</ul>
<p>Note that while a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-discoveryrequest-response-nonce"><span class="std std-ref">response_nonce</span></a> may
be set on the request, the server must honor changes to the subscription state even if the nonce is stale. The nonce
may be used to correlate an ack/nack with a server response, but should <em>not</em> be used to reject stale requests.</p>
<p>In this first example the client connects and receives a first update
that it ACKs. The second update fails and the client NACKs the update.
Later the xDS client spontaneously requests the “wc” resource.</p>
<div class="figure align-default">
<img alt="Incremental session example" src="../_images/incremental.svg" /></div>
<p>On reconnect the Incremental xDS client may tell the server of its known
resources to avoid resending them over the network by sending them in
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-initial-resource-versions"><span class="std std-ref">initial_resource_versions</span></a>.
Because no state is assumed to be preserved from the previous stream, the reconnecting
client must provide the server with all resource names it is interested in.</p>
<p>Note that for “wildcard” subscriptions (see <a class="reference internal" href="#xds-protocol-resource-hints"><span class="std std-ref">How the client specifies what
resources to return</span></a> for details), the
request must either specify “*” in the <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a>
field or (legacy behavior) the request must have no resources in both
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a> and
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-unsubscribe"><span class="std std-ref">resource_names_unsubscribe</span></a>.</p>
<div class="figure align-default">
<img alt="Incremental reconnect example" src="../_images/incremental-reconnect.svg" /></div>
<div class="section" id="resource-names">
<h4>Resource names<a class="headerlink" href="#resource-names" title="Permalink to this headline">¶</a></h4>
<p>Resources are identified by a resource name or an alias. Aliases of a
resource, if present, can be identified by the alias field in the
resource of a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryresponse"><span class="std std-ref">DeltaDiscoveryResponse</span></a>. The resource name will be
returned in the name field in the resource of a
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryresponse"><span class="std std-ref">DeltaDiscoveryResponse</span></a>.</p>
</div>
<div class="section" id="subscribing-to-resources">
<span id="xds-protocol-delta-subscribe"></span><h4>Subscribing to Resources<a class="headerlink" href="#subscribing-to-resources" title="Permalink to this headline">¶</a></h4>
<p>The client can send either an alias or the name of a resource in the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a> field of a <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a> in
order to subscribe to a resource. Both the names and aliases of
resources should be checked in order to determine whether the entity in
question has been subscribed to.</p>
<p>A <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a> field may contain resource names that the
server believes the client is already subscribed to, and furthermore has
the most recent versions of. However, the server <em>must</em> still provide
those resources in the response; due to implementation details hidden
from the server, the client may have “forgotten” those resources despite
apparently remaining subscribed.</p>
</div>
<div class="section" id="xds-protocol-unsubscribe">
<span id="id1"></span><h4>Unsubscribing from Resources<a class="headerlink" href="#xds-protocol-unsubscribe" title="Permalink to this headline">¶</a></h4>
<p>When a client loses interest in some resources, it will indicate that
with the <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-unsubscribe"><span class="std std-ref">resource_names_unsubscribe</span></a> field of a
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryrequest"><span class="std std-ref">DeltaDiscoveryRequest</span></a>. As with <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-subscribe"><span class="std std-ref">resource_names_subscribe</span></a>, these
may be resource names or aliases.</p>
<p>A <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryrequest-resource-names-unsubscribe"><span class="std std-ref">resource_names_unsubscribe</span></a> field may contain superfluous resource
names, which the server thought the client was already not subscribed
to. The server must cleanly process such a request; it can simply ignore
these phantom unsubscriptions.</p>
<p>In most cases (see below for exception), a server does not need to send any response if a request
does nothing except unsubscribe from a resource; in particular, servers are not generally required
to send a response with the unsubscribed resource name in the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryresponse-removed-resources"><span class="std std-ref">removed_resources</span></a>
field.</p>
<p>However, there is one exception to the above: When a client has a wildcard subscription (“*”) <em>and</em>
a subscription to another specific resource name, it is possible that the specific resource name is
also included in the wildcard subscription, so if the client unsubscribes from that specific
resource name, it does not know whether or not to continue to cache the resource. To address this,
the server must send a response that includes the specific resource in either the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryresponse-removed-resources"><span class="std std-ref">removed_resources</span></a>
field (if it is not included in the wildcard) or in the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryresponse-resources"><span class="std std-ref">resources</span></a>
field (if it <em>is</em> included in the wildcard).</p>
</div>
<div class="section" id="id2">
<h4>Knowing When a Requested Resource Does Not Exist<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>When a resource subscribed to by a client does not exist, the server
will send a
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-deltadiscoveryresponse"><span class="std std-ref">DeltaDiscoveryResponse</span></a>
message that contains that resource’s name in the
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-field-service-discovery-v3-deltadiscoveryresponse-removed-resources"><span class="std std-ref">removed_resources</span></a>
field. This allows the client to quickly determine when a resource does not exist without
waiting for a timeout, as would be done in the SotW protocol variants. However, clients are still
encouraged to use a timeout to protect against the case where the management server fails to send
a response in a timely manner.</p>
</div>
</div>
</div>
<div class="section" id="rest-json-polling-subscriptions">
<h2>REST-JSON polling subscriptions<a class="headerlink" href="#rest-json-polling-subscriptions" title="Permalink to this headline">¶</a></h2>
<p>Synchronous (long) polling via REST endpoints is also available for the
xDS singleton APIs. The above sequencing of messages is similar, except
no persistent stream is maintained to the management server. It is
expected that there is only a single outstanding request at any point in
time, and as a result the response nonce is optional in REST-JSON. The
<a class="reference external" href="https://developers.google.com/protocol-buffers/docs/proto3#json">JSON canonical transform of
proto3</a>
is used to encode <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryrequest"><span class="std std-ref">DiscoveryRequest</span></a> and <a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a>
messages. ADS is not available for REST-JSON polling.</p>
<p>When the poll period is set to a small value, with the intention of long
polling, then there is also a requirement to avoid sending a
<a class="reference internal" href="../api-v3/service/discovery/v3/discovery.proto.html#envoy-v3-api-msg-service-discovery-v3-discoveryresponse"><span class="std std-ref">DiscoveryResponse</span></a> unless a change to the underlying resources has
occurred via a <a class="reference internal" href="#xds-protocol-resource-update"><span class="std std-ref">resource update</span></a>.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../api-v3/type/tracing/v3/custom_tag.proto.html" class="btn btn-neutral float-left" title="Custom Tag" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../api/client_features.html" class="btn btn-neutral float-right" title="Well Known Client Features" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2022, Envoy Project Authors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>