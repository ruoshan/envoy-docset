

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Service discovery &mdash; envoy 1.17.0-5c801b documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/envoy.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sphinx_tabs/semantic-ui-2.4.1/segment.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sphinx_tabs/semantic-ui-2.4.1/menu.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sphinx_tabs/tabs.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="DNS Resolution" href="dns_resolution.html" />
    <link rel="prev" title="Cluster manager" href="cluster_manager.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/envoy-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.17.0-5c801b
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../about_docs.html">About the documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../intro.html">Introduction</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../what_is_envoy.html">What is Envoy</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../arch_overview.html">Architecture overview</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../intro/intro.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../listeners/listeners_toc.html">Listeners</a></li>
<li class="toctree-l3"><a class="reference internal" href="../http/http.html">HTTP</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="upstream.html">Upstream clusters</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="cluster_manager.html">Cluster manager</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Service discovery</a></li>
<li class="toctree-l4"><a class="reference internal" href="dns_resolution.html">DNS Resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="health_checking.html">Health checking</a></li>
<li class="toctree-l4"><a class="reference internal" href="connection_pooling.html">Connection pooling</a></li>
<li class="toctree-l4"><a class="reference internal" href="load_balancing/load_balancing.html">Load Balancing</a></li>
<li class="toctree-l4"><a class="reference internal" href="aggregate_cluster.html">Aggregate Cluster</a></li>
<li class="toctree-l4"><a class="reference internal" href="outlier.html">Outlier detection</a></li>
<li class="toctree-l4"><a class="reference internal" href="circuit_breaking.html">Circuit breaking</a></li>
<li class="toctree-l4"><a class="reference internal" href="upstream_filters.html">Upstream network filters</a></li>
<li class="toctree-l4"><a class="reference internal" href="load_reporting_service.html">Load Reporting Service (LRS)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../observability/observability.html">Observability</a></li>
<li class="toctree-l3"><a class="reference internal" href="../security/security.html">Security</a></li>
<li class="toctree-l3"><a class="reference internal" href="../operations/operations.html">Operations &amp; configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../other_features/other_features.html">Other features</a></li>
<li class="toctree-l3"><a class="reference internal" href="../other_protocols/other_protocols.html">Other protocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../advanced/advanced.html">Advanced</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../life_of_a_request.html">Life of a Request</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../deployment_types/deployment_types.html">Deployment types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../getting_help.html">Getting help</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../start/start.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../configuration/configuration.html">Configuration reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../operations/operations.html">Operations and administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extending/extending.html">Extending Envoy for custom use cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/overview.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../version_history/version_history.html">Version history</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">envoy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../intro.html">Introduction</a> &raquo;</li>
        
          <li><a href="../arch_overview.html">Architecture overview</a> &raquo;</li>
        
          <li><a href="upstream.html">Upstream clusters</a> &raquo;</li>
        
      <li>Service discovery</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/intro/arch_overview/upstream/service_discovery.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="service-discovery">
<span id="arch-overview-service-discovery"></span><h1>Service discovery<a class="headerlink" href="#service-discovery" title="Permalink to this headline">¶</a></h1>
<p>When an upstream cluster is defined in the <a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-msg-config-cluster-v3-cluster"><span class="std std-ref">configuration</span></a>,
Envoy needs to know how to resolve the members of the cluster. This is known as <em>service discovery</em>.</p>
<div class="section" id="supported-service-discovery-types">
<span id="arch-overview-service-discovery-types"></span><h2>Supported service discovery types<a class="headerlink" href="#supported-service-discovery-types" title="Permalink to this headline">¶</a></h2>
<div class="section" id="static">
<span id="arch-overview-service-discovery-types-static"></span><h3>Static<a class="headerlink" href="#static" title="Permalink to this headline">¶</a></h3>
<p>Static is the simplest service discovery type. The configuration explicitly specifies the resolved
network name (IP address/port, unix domain socket, etc.) of each upstream host.</p>
</div>
<div class="section" id="strict-dns">
<span id="arch-overview-service-discovery-types-strict-dns"></span><h3>Strict DNS<a class="headerlink" href="#strict-dns" title="Permalink to this headline">¶</a></h3>
<p>When using strict DNS service discovery, Envoy will continuously and asynchronously resolve the
specified DNS targets. Each returned IP address in the DNS result will be considered an explicit
host in the upstream cluster. This means that if the query returns three IP addresses, Envoy will
assume the cluster has three hosts, and all three should be load balanced to. If a host is removed
from the result Envoy assumes it no longer exists and will drain traffic from any existing
connection pools. Consequently, if a successful DNS resolution returns 0 hosts, Envoy will assume
that the cluster does not have any hosts. Note that Envoy never synchronously resolves DNS in the
forwarding path. At the expense of eventual consistency, there is never a worry of blocking on a
long running DNS query.</p>
<p>If a single DNS name resolves to the same IP multiple times, these IPs will be de-duplicated.</p>
<p>If multiple DNS names resolve to the same IP, health checking will <em>not</em> be shared.
This means that care should be taken if active health checking is used with DNS names that resolve
to the same IPs: if an IP is repeated many times between DNS names it might cause undue load on the
upstream host.</p>
<p>If <a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-respect-dns-ttl"><span class="std std-ref">respect_dns_ttl</span></a> is enabled, DNS record TTLs and
<a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-dns-refresh-rate"><span class="std std-ref">dns_refresh_rate</span></a> are used to control DNS refresh rate.
For strict DNS cluster, if the minimum of all record TTLs is 0, <a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-dns-refresh-rate"><span class="std std-ref">dns_refresh_rate</span></a>
will be used as the cluster’s DNS refresh rate. <a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-dns-refresh-rate"><span class="std std-ref">dns_refresh_rate</span></a>
defaults to 5000ms if not specified. The <a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-dns-failure-refresh-rate"><span class="std std-ref">dns_failure_refresh_rate</span></a>
controls the refresh frequency during failures, and, if not configured, the DNS refresh rate will be used.</p>
<p>DNS resolving emits <a class="reference internal" href="../../../configuration/upstream/cluster_manager/cluster_stats.html#config-cluster-manager-cluster-stats"><span class="std std-ref">cluster statistics</span></a> fields <em>update_attempt</em>, <em>update_success</em> and <em>update_failure</em>.</p>
</div>
<div class="section" id="logical-dns">
<span id="arch-overview-service-discovery-types-logical-dns"></span><h3>Logical DNS<a class="headerlink" href="#logical-dns" title="Permalink to this headline">¶</a></h3>
<p>Logical DNS uses a similar asynchronous resolution mechanism to strict DNS. However, instead of
strictly taking the results of the DNS query and assuming that they comprise the entire upstream
cluster, a logical DNS cluster only uses the first IP address returned <em>when a new connection needs
to be initiated</em>. Thus, a single logical connection pool may contain physical connections to a
variety of different upstream hosts. Connections are never drained,
including on a successful DNS resolution that returns 0 hosts.</p>
<p>This service discovery type is
optimal for large scale web services that must be accessed via DNS. Such services typically use
round robin DNS to return many different IP addresses. Typically a different result is returned for
each query. If strict DNS were used in this scenario, Envoy would assume that the cluster’s members
were changing during every resolution interval which would lead to draining connection pools,
connection cycling, etc. Instead, with logical DNS, connections stay alive until they get cycled.
When interacting with large scale web services, this is the best of all possible worlds:
asynchronous/eventually consistent DNS resolution, long lived connections, and zero blocking in the
forwarding path.</p>
<p>If <a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-respect-dns-ttl"><span class="std std-ref">respect_dns_ttl</span></a> is enabled, DNS record TTLs and
<a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-dns-refresh-rate"><span class="std std-ref">dns_refresh_rate</span></a> are used to control DNS refresh rate.
For logical DNS cluster, if the TTL of first record is 0, <a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-dns-refresh-rate"><span class="std std-ref">dns_refresh_rate</span></a>
will be used as the cluster’s DNS refresh rate. <a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-dns-refresh-rate"><span class="std std-ref">dns_refresh_rate</span></a>
defaults to 5000ms if not specified. The <a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-dns-failure-refresh-rate"><span class="std std-ref">dns_failure_refresh_rate</span></a>
controls the refresh frequency during failures, and, if not configured, the DNS refresh rate will be used.</p>
<p>DNS resolving emits <a class="reference internal" href="../../../configuration/upstream/cluster_manager/cluster_stats.html#config-cluster-manager-cluster-stats"><span class="std std-ref">cluster statistics</span></a> fields <em>update_attempt</em>, <em>update_success</em> and <em>update_failure</em>.</p>
</div>
<div class="section" id="original-destination">
<span id="arch-overview-service-discovery-types-original-destination"></span><h3>Original destination<a class="headerlink" href="#original-destination" title="Permalink to this headline">¶</a></h3>
<p>Original destination cluster can be used when incoming connections are redirected to Envoy either
via an iptables REDIRECT or TPROXY target or with Proxy Protocol. In these cases requests routed
to an original destination cluster are forwarded to upstream hosts as addressed by the redirection
metadata, without any explicit host configuration or upstream host discovery.
Connections to upstream hosts are pooled and unused hosts are flushed out when they have been idle longer than
<a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-cleanup-interval"><span class="std std-ref">cleanup_interval</span></a>, which defaults to
5000ms. If the original destination address is not available, no upstream connection is opened.
Envoy can also pickup the original destination from a <a class="reference internal" href="load_balancing/original_dst.html#arch-overview-load-balancing-types-original-destination-request-header"><span class="std std-ref">HTTP header</span></a>.
Original destination service discovery must be used with the original destination <a class="reference internal" href="load_balancing/original_dst.html#arch-overview-load-balancing-types-original-destination"><span class="std std-ref">load
balancer</span></a>.</p>
</div>
<div class="section" id="endpoint-discovery-service-eds">
<span id="arch-overview-service-discovery-types-eds"></span><h3>Endpoint discovery service (EDS)<a class="headerlink" href="#endpoint-discovery-service-eds" title="Permalink to this headline">¶</a></h3>
<p>The <em>endpoint discovery service</em> is a <a class="reference internal" href="../../../configuration/overview/xds_api.html#config-overview-management-server"><span class="std std-ref">xDS management server based on gRPC or REST-JSON API server</span></a> used by Envoy to fetch cluster members. The cluster members are called
“endpoint” in Envoy terminology. For each cluster, Envoy fetch the endpoints from the discovery service. EDS is the
preferred service discovery mechanism for a few reasons:</p>
<ul class="simple">
<li><p>Envoy has explicit knowledge of each upstream host (vs. routing through a DNS resolved load
balancer) and can make more intelligent load balancing decisions.</p></li>
<li><p>Extra attributes carried in the discovery API response for each host inform Envoy of the host’s
load balancing weight, canary status, zone, etc. These additional attributes are used globally
by the Envoy mesh during load balancing, statistic gathering, etc.</p></li>
</ul>
<p>The Envoy project provides reference gRPC implementations of EDS and
<a class="reference internal" href="../operations/dynamic_configuration.html#arch-overview-dynamic-config"><span class="std std-ref">other discovery services</span></a>
in both <a class="reference external" href="https://github.com/envoyproxy/java-control-plane">Java</a>
and <a class="reference external" href="https://github.com/envoyproxy/go-control-plane">Go</a>.</p>
</div>
<div class="section" id="custom-cluster">
<span id="arch-overview-service-discovery-types-custom"></span><h3>Custom cluster<a class="headerlink" href="#custom-cluster" title="Permalink to this headline">¶</a></h3>
<p>Envoy also supports custom cluster discovery mechanism. Custom clusters are specified using
<a class="reference internal" href="../../../api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-field-config-cluster-v3-cluster-cluster-type"><span class="std std-ref">cluster_type field</span></a> on the cluster configuration.</p>
<p>Generally active health checking is used in conjunction with the eventually consistent service
discovery service data to making load balancing and routing decisions. This is discussed further in
the following section.</p>
</div>
</div>
<div class="section" id="on-eventually-consistent-service-discovery">
<span id="arch-overview-service-discovery-eventually-consistent"></span><h2>On eventually consistent service discovery<a class="headerlink" href="#on-eventually-consistent-service-discovery" title="Permalink to this headline">¶</a></h2>
<p>Many existing RPC systems treat service discovery as a fully consistent process. To this end, they
use fully consistent leader election backing stores such as Zookeeper, etcd, Consul, etc. Our
experience has been that operating these backing stores at scale is painful.</p>
<p>Envoy was designed from the beginning with the idea that service discovery does not require full
consistency. Instead, Envoy assumes that hosts come and go from the mesh in an eventually consistent
way. Our recommended way of deploying a service to service Envoy mesh configuration uses eventually
consistent service discovery along with <a class="reference internal" href="health_checking.html#arch-overview-health-checking"><span class="std std-ref">active health checking</span></a>
(Envoy explicitly health checking upstream cluster members) to determine cluster health. This
paradigm has a number of benefits:</p>
<ul class="simple">
<li><p>All health decisions are fully distributed. Thus, network partitions are gracefully handled
(whether the application gracefully handles the partition is a different story).</p></li>
<li><p>When health checking is configured for an upstream cluster, Envoy uses a 2x2 matrix to determine
whether to route to a host:</p></li>
</ul>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Discovery Status</p></th>
<th class="head"><p>Health Check OK</p></th>
<th class="head"><p>Health Check Failed</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Discovered</p></td>
<td><p>Route</p></td>
<td><p>Don’t Route</p></td>
</tr>
<tr class="row-odd"><td><p>Absent</p></td>
<td><p>Route</p></td>
<td><p>Don’t Route / Delete</p></td>
</tr>
</tbody>
</table>
<dl class="simple">
<dt>Host discovered / health check OK</dt><dd><p>Envoy <strong>will route</strong> to the target host.</p>
</dd>
<dt>Host absent / health check OK:</dt><dd><p>Envoy <strong>will route</strong> to the target host. This is very important since the design assumes that the
discovery service can fail at any time. If a host continues to pass health check even after becoming
absent from the discovery data, Envoy will still route. Although it would be impossible to add new
hosts in this scenario, existing hosts will continue to operate normally. When the discovery service
is operating normally again the data will eventually re-converge.</p>
</dd>
<dt>Host discovered / health check FAIL</dt><dd><p>Envoy <strong>will not route</strong> to the target host. Health check data is assumed to be more accurate than
discovery data.</p>
</dd>
<dt>Host absent / health check FAIL</dt><dd><p>Envoy <strong>will not route and will delete</strong> the target host. This
is the only state in which Envoy will purge host data.</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dns_resolution.html" class="btn btn-neutral float-right" title="DNS Resolution" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cluster_manager.html" class="btn btn-neutral float-left" title="Cluster manager" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2016-2021, Envoy Project Authors

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>